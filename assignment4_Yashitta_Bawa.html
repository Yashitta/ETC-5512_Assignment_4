<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Yashitta Bawa">

<title>What Drives Viewer Engagement on Netflix?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="assignment4_Yashitta_Bawa_files/libs/clipboard/clipboard.min.js"></script>
<script src="assignment4_Yashitta_Bawa_files/libs/quarto-html/quarto.js"></script>
<script src="assignment4_Yashitta_Bawa_files/libs/quarto-html/popper.min.js"></script>
<script src="assignment4_Yashitta_Bawa_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="assignment4_Yashitta_Bawa_files/libs/quarto-html/anchor.min.js"></script>
<link href="assignment4_Yashitta_Bawa_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="assignment4_Yashitta_Bawa_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="assignment4_Yashitta_Bawa_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="assignment4_Yashitta_Bawa_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="assignment4_Yashitta_Bawa_files/libs/bootstrap/bootstrap-e64f0373aecd96a0501e06a3c6cba34c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


<link rel="stylesheet" href="styles.css">
</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">What Drives Viewer Engagement on Netflix?</h1>
<p class="subtitle lead">Assignment 4 ETC5512</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Yashitta Bawa </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" role="tab" aria-controls="tabset-1-1" aria-selected="true" href="">Data Details</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-2" role="tab" aria-controls="tabset-1-2" aria-selected="false" href="">Blog post</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-3" role="tab" aria-controls="tabset-1-3" aria-selected="false" href="">Behind the Scenes</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-1-1-tab">
<section id="research-question" class="level3">
<h3 class="anchored" data-anchor-id="research-question">üß† Research Question</h3>
<p>This project explores the question: <strong>What drives viewer engagement on Netflix?</strong></p>
<p>The goal is to determine which types of content‚Äîsuch as genres, release formats, or show categories‚Äîtend to attract the highest viewership. Specifically, the analysis investigates:</p>
<ul>
<li>Whether certain genres (e.g., documentaries, thrillers, reality shows) sustain more viewer attention<br>
</li>
<li>Whether newer titles perform better than older ones<br>
</li>
<li>What common characteristics are shared by the most-watched shows</li>
</ul>
<p>This question was selected because streaming platforms like Netflix play a major role in everyday entertainment. Gaining insight into what makes certain content more engaging can help illuminate viewer preferences, binge-watching behavior, and content design strategies.</p>
<hr>
</section>
<section id="the-data" class="level3">
<h3 class="anchored" data-anchor-id="the-data">üìÅ The Data</h3>
<p>Two datasets were used in this project:</p>
<ol type="1">
<li><p><strong>Netflix Engagement Report (Jan‚ÄìJun 2023)</strong><br>
This dataset, published by Netflix, includes total hours watched globally for each title, along with release dates. It reflects real-world viewership patterns and provides a direct measure of audience engagement.</p></li>
<li><p><strong>Netflix Titles Metadata (from Kaggle)</strong><br>
This dataset contains descriptive information about Netflix content, including title, type (TV show or movie), duration (either runtime in minutes or number of seasons), genre categories, and release year.</p></li>
</ol>
<p>These datasets were selected because they are <strong>publicly available</strong>, nclude the <strong>relevant variables</strong> needed to address the research question, and are <strong>up-to-date</strong> as of 2023.</p>
<p>They are appropriate for the intended analysis because:</p>
<ul>
<li><p>The engagement data directly captures viewer attention</p></li>
<li><p>The metadata allows for grouping by format and genre</p></li>
<li><p>Both datasets are observational and structurally compatible after cleanings</p></li>
</ul>
<p><strong>Licensing</strong>:</p>
<ul>
<li><p>The engagement report is published by Netflix and is freely downloadable from the Netflix What We Watched site</p></li>
<li><p>The titles dataset is available on Kaggle under a public license</p></li>
</ul>
<hr>
</section>
<section id="data-collection-and-preparation" class="level3">
<h3 class="anchored" data-anchor-id="data-collection-and-preparation">üõ†Ô∏è Data Collection and Preparation</h3>
<p><strong>Download Process:</strong></p>
<ul>
<li><p>The engagement data was downloaded as an Excel spreadsheet from the Netflix What We Watched website.</p></li>
<li><p>The titles data was downloaded in CSV format from Kaggle.</p></li>
</ul>
<p><strong>Data Cleaning and Processing:</strong></p>
<ul>
<li><p>The engagement report included a non-tabular header section, which was skipped.</p></li>
<li><p>Column names were cleaned and standardized using the <code>janitor</code> package.</p></li>
<li><p>The <code>title</code> column was standardized across both datasets by converting text to lowercase and trimming white space.</p></li>
<li><p>Only relevant variables were retained, including title, hours viewed, release date, genre, and type.</p></li>
<li><p>The two datasets were merged using the cleaned <code>title</code> column.</p></li>
<li><p>Some shows appeared multiple times in the engagement data (e.g., one row per season). These entries were retained for more granular analysis.</p></li>
<li><p>The <code>duration</code> column indicates runtime in minutes for movies and season count for TV shows, which limits direct comparisons across formats.</p></li>
</ul>
<p>These steps ensured the datasets were clean, merged, and ready for structured analysis and visualization.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Loaded required libraries</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(readr)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(readxl)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(here)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(janitor)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(stringr)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(lubridate)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyr)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(plotly)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(scales)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggridges)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(patchwork)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Loaded the datasets</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>titles <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(<span class="fu">here</span>(<span class="st">"data/netflix_titles.csv"</span>)) <span class="sc">%&gt;%</span> </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">clean_names</span>()</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>engagement_report <span class="ot">&lt;-</span> <span class="fu">read_excel</span>(<span class="fu">here</span>(<span class="st">"data/Netflix_Engagement_Report.xlsx"</span>), </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>                                     <span class="at">skip =</span> <span class="dv">5</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">clean_names</span>()</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Standardised the titles for merging</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>titles <span class="ot">&lt;-</span> titles <span class="sc">%&gt;%</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">title_clean =</span> <span class="fu">str_to_lower</span>(<span class="fu">str_trim</span>(title)))</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>engagement_report <span class="ot">&lt;-</span> engagement_report <span class="sc">%&gt;%</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">title_clean =</span> <span class="fu">str_to_lower</span>(<span class="fu">str_trim</span>(title)),</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="at">release_year =</span> lubridate<span class="sc">::</span><span class="fu">year</span>(release_date))</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Merged datasets using a left join</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>netflix_clean <span class="ot">&lt;-</span> <span class="fu">left_join</span>(engagement_report, titles, <span class="at">by =</span> <span class="st">"title_clean"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(type), <span class="sc">!</span><span class="fu">is.na</span>(duration), <span class="sc">!</span><span class="fu">is.na</span>(listed_in)) <span class="sc">%&gt;%</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="at">release_year =</span> lubridate<span class="sc">::</span><span class="fu">year</span>(release_date)) <span class="sc">%&gt;%</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(<span class="at">title =</span> title.x,</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>         release_date,</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>         hours_viewed,</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>         release_year,</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>         type, </span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>         duration, </span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>         listed_in)</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a><span class="co"># Added a new column with season removed</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>netflix_clean <span class="ot">&lt;-</span> netflix_clean <span class="sc">%&gt;%</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">base_title =</span> <span class="fu">str_remove</span>(title, <span class="st">": Season </span><span class="sc">\\</span><span class="st">d+|: Limited Series"</span>))</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="co"># Group by base title + genre/type and summarise</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>netflix_grouped <span class="ot">&lt;-</span> netflix_clean <span class="sc">%&gt;%</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(base_title, type, listed_in) <span class="sc">%&gt;%</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarise</span>(</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    <span class="at">total_hours =</span> <span class="fu">sum</span>(hours_viewed, <span class="at">na.rm =</span> <span class="cn">TRUE</span>),</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>    <span class="at">.groups =</span> <span class="st">"drop"</span>)</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a><span class="co"># Separated movie duration (in minutes) and show duration (season count)</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>netflix_clean <span class="ot">&lt;-</span> netflix_clean <span class="sc">%&gt;%</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>    <span class="at">duration_num =</span> <span class="fu">parse_number</span>(duration),</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>    <span class="at">duration_type =</span> <span class="fu">case_when</span>(</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_detect</span>(duration, <span class="st">"min"</span>) <span class="sc">~</span> <span class="st">"minutes"</span>,</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_detect</span>(duration, <span class="st">"Season"</span>) <span class="sc">~</span> <span class="st">"seasons"</span>,</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>      <span class="cn">TRUE</span> <span class="sc">~</span> <span class="st">"unknown"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
</section>
<section id="dataset-creation-for-visualisation" class="level3">
<h3 class="anchored" data-anchor-id="dataset-creation-for-visualisation">üìä Dataset Creation for Visualisation</h3>
<p><strong>Genre Breakdown: Most Watched Categories Overall</strong></p>
<p>To identify which genres attract the highest viewership, multi-genre entries were separated, and total hours viewed were aggregated for each individual genre.</p>
<p>To explore trends across formats, the dataset was further grouped by both <code>type</code> (Movie or TV Show) and <code>genre</code>. The top 10 genres for each format were selected based on total viewing hours, then combined into a single dataset to allow visual comparison. While some genres appeared in both lists (e.g., Dramas, Sci-Fi &amp; Fantasy), others were format-specific‚Äîsuch as Crime TV Shows or Romantic Movies.</p>
<p>This preparation enabled a clear side-by-side breakdown of audience preferences by format, visualised through a faceted bar chart in the blog post tab. The plot reveals which genres perform better within each format and illustrates how structural differences in content influence viewership.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>genre_summary <span class="ot">&lt;-</span> netflix_clean <span class="sc">%&gt;%</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">separate_rows</span>(listed_in, <span class="at">sep =</span> <span class="st">",</span><span class="sc">\\</span><span class="st">s*"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(listed_in) <span class="sc">%&gt;%</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarise</span>(<span class="at">total_hours =</span> <span class="fu">sum</span>(hours_viewed, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)) <span class="sc">%&gt;%</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(total_hours)) <span class="sc">%&gt;%</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">slice_head</span>(<span class="at">n =</span> <span class="dv">10</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Preprocess genre order</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>genre_summary <span class="ot">&lt;-</span> genre_summary <span class="sc">%&gt;%</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">listed_in =</span> <span class="fu">factor</span>(listed_in, </span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>                            <span class="at">levels =</span> listed_in[<span class="fu">order</span>(total_hours)]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Genre Preferences by Format</strong></p>
<p>To compare viewership patterns between TV shows and movies, titles were grouped by type, and summary statistics‚Äîsuch as mean and median hours viewed‚Äîwere calculated.</p>
<p>To further examine genre-based viewing trends across formats, titles were grouped by both <code>type</code> and <code>genre</code>, and total viewing hours were aggregated.<br>
</p>
<p>The top 10 genres for each format were then selected to showcase the most popular categories, with overlapping genres retained to allow comparison.</p>
<p>This data was used to create a <strong>side-by-side faceted bar chart</strong>, displaying the top genres by total hours viewed for <strong>movies</strong> on the left and <strong>TV shows</strong> on the right.<br>
</p>
<p>The layout highlights which genres perform better within each content format.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>format_summary <span class="ot">&lt;-</span> netflix_clean <span class="sc">%&gt;%</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(type) <span class="sc">%&gt;%</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarise</span>(</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">mean_hours =</span> <span class="fu">mean</span>(hours_viewed, <span class="at">na.rm =</span> <span class="cn">TRUE</span>),</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">median_hours =</span> <span class="fu">median</span>(hours_viewed, <span class="at">na.rm =</span> <span class="cn">TRUE</span>),</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">count =</span> <span class="fu">n</span>())</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Full summary of genres by format</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>genre_all <span class="ot">&lt;-</span> netflix_clean <span class="sc">%&gt;%</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">separate_rows</span>(listed_in, <span class="at">sep =</span> <span class="st">",</span><span class="sc">\\</span><span class="st">s*"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(type, <span class="at">genre =</span> listed_in) <span class="sc">%&gt;%</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarise</span>(<span class="at">hours_viewed =</span> <span class="fu">sum</span>(hours_viewed, <span class="at">na.rm =</span> <span class="cn">TRUE</span>), <span class="at">.groups =</span> <span class="st">"drop"</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Top 10 Movie genres</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>top_movie_genres <span class="ot">&lt;-</span> genre_all <span class="sc">%&gt;%</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(type <span class="sc">==</span> <span class="st">"Movie"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(hours_viewed)) <span class="sc">%&gt;%</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">slice_head</span>(<span class="at">n =</span> <span class="dv">10</span>) <span class="sc">%&gt;%</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(genre)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Top 10 TV genres</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>top_tv_genres <span class="ot">&lt;-</span> genre_all <span class="sc">%&gt;%</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(type <span class="sc">==</span> <span class="st">"TV Show"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(hours_viewed)) <span class="sc">%&gt;%</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">slice_head</span>(<span class="at">n =</span> <span class="dv">10</span>) <span class="sc">%&gt;%</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(genre)</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Combine all 20 genres (with overlap if any)</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>selected_genres <span class="ot">&lt;-</span> <span class="fu">union</span>(top_movie_genres, top_tv_genres)</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Final dataset: includes Movie + TV rows for those 20 genres</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>genre_by_type <span class="ot">&lt;-</span> genre_all <span class="sc">%&gt;%</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(genre <span class="sc">%in%</span> selected_genres)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Duration vs.&nbsp;Format</strong></p>
<p>To explore how content length varies between movies and TV shows, the <code>duration</code> column was cleaned and split into two distinct units: <strong>minutes</strong> (for movies) and <strong>seasons</strong> (for TV shows). These values were extracted numerically and stored in a new column called <code>duration_num</code>.</p>
<p>Entries labelled as ‚Äúother‚Äù or missing type/duration values were filtered out to create a consistent dataset for comparing structural differences in content length.</p>
<p>The cleaned dataset was then split by format (<code>Movie</code> vs <code>TV Show</code>) and visualised using <strong>violin plots</strong>. Each plot displays the distribution of durations across titles, offering insight into how runtime conventions differ by format.</p>
<p>For instance, movies typically range from 90‚Äì120 minutes, while most TV shows cluster around 1‚Äì2 seasons. This transformation supports a focused visualisation of <strong>duration norms</strong> and lays the foundation for analysing their relationship with viewer engagement.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>duration_clean <span class="ot">&lt;-</span> netflix_clean <span class="sc">%&gt;%</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">duration_num =</span> readr<span class="sc">::</span><span class="fu">parse_number</span>(duration),</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">duration_type =</span> <span class="fu">case_when</span>(</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_detect</span>(duration, <span class="st">"min"</span>) <span class="sc">~</span> <span class="st">"minutes"</span>,</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_detect</span>(duration, <span class="st">"Season"</span>) <span class="sc">~</span> <span class="st">"seasons"</span>,</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>      <span class="cn">TRUE</span> <span class="sc">~</span> <span class="st">"other"</span>)) <span class="sc">%&gt;%</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(duration_num))</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Clean duration data</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>duration_clean <span class="ot">&lt;-</span> netflix_clean <span class="sc">%&gt;%</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(duration), </span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>         <span class="sc">!</span><span class="fu">is.na</span>(type)) <span class="sc">%&gt;%</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">duration_num =</span> <span class="fu">case_when</span>(</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_detect</span>(duration, <span class="st">"min"</span>) <span class="sc">~</span> <span class="fu">parse_number</span>(duration),</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_detect</span>(duration, <span class="st">"Season"</span>) <span class="sc">~</span> <span class="fu">parse_number</span>(duration),</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>      <span class="cn">TRUE</span> <span class="sc">~</span> <span class="cn">NA_real_</span>),</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="at">duration_unit =</span> <span class="fu">case_when</span>(</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_detect</span>(duration, <span class="st">"min"</span>) <span class="sc">~</span> <span class="st">"Minutes"</span>,</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_detect</span>(duration, <span class="st">"Season"</span>) <span class="sc">~</span> <span class="st">"Seasons"</span>,</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>      <span class="cn">TRUE</span> <span class="sc">~</span> <span class="st">"Other"</span>)) <span class="sc">%&gt;%</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(duration_num), </span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>         duration_unit <span class="sc">!=</span> <span class="st">"Other"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
</section>
<section id="references" class="level3">
<h3 class="anchored" data-anchor-id="references">üìö References</h3>
<ul>
<li>Netflix. <em>What We Watched: A Netflix Engagement Report</em>. Retrieved from: <a href="https://about.netflix.com/en/news/what-we-watched-a-netflix-engagement-report"><em>Netflix</em></a><br>
</li>
<li>Shivamb. <em>Netflix Movies and TV Shows Dataset</em>. Retrieved from: <a href="https://www.kaggle.com/datasets/shivamb/netflix-shows"><em>Kaggle</em></a><br>
</li>
<li>R Packages used: <code>readxl</code>, <code>readr</code>, <code>dplyr</code>, <code>stringr</code>, <code>janitor</code>, <code>lubridate</code>, <code>here</code>, <code>tidyr</code></li>
</ul>
<hr>
</section>
<section id="ai-acknowledgment" class="level3">
<h3 class="anchored" data-anchor-id="ai-acknowledgment">ü§ñ AI Acknowledgment</h3>
<p>Parts of this project, including text refinement, paraphrasing, and grammar correction, were supported by OpenAI‚Äôs ChatGPT. The AI was used to enhance clarity, coherence, and flow in the written sections, while all core ideas, analyses, and interpretations remain the original work of the author. Here is the link for the <a href="https://chatgpt.com/share/68502201-27d0-800c-8cb0-023fc4eb1f2d">ChatGPT Query.</a></p>
<!-- Task 2 Tab: Writing your blogpost -->
</section>
</div>
<div id="tabset-1-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-2-tab">
<section id="motivation" class="level3">
<h3 class="anchored" data-anchor-id="motivation">üé¨ Motivation</h3>
<p>With Netflix offering everything from gritty thrillers to romantic comedies, it‚Äôs natural to wonder: <strong>what actually keeps people watching?</strong><br>
This project investigates how genre, content type, and show structure influence viewer engagement. By leveraging real-world viewing data, it uncovers patterns that help explain why some shows become binge-worthy while others fade into the background.</p>
<hr>
</section>
<section id="data" class="level3">
<h3 class="anchored" data-anchor-id="data">üìä Data</h3>
<p>The analysis is based on two combined datasets:</p>
<ul>
<li>The <strong>Netflix Engagement Report (Jan‚ÄìJun 2023)</strong>, which lists total global viewing hours for each title.</li>
<li>A <strong>Netflix title dataset</strong> from Kaggle, providing additional details such as genre, content type (TV show or movie), and duration.</li>
</ul>
<p>After merging and cleaning, each row in the final dataset represents a specific show or season along with its total hours viewed. This structured dataset allows for meaningful comparisons across genres, formats, and content lengths.</p>
<hr>
</section>
<section id="analysis" class="level3">
<h3 class="anchored" data-anchor-id="analysis">üìà Analysis</h3>
<section id="top-genres-by-total-viewing-time" class="level4">
<h4 class="anchored" data-anchor-id="top-genres-by-total-viewing-time"><strong>1. Top Genres by Total Viewing Time</strong></h4>
<p><strong>Most-Watched Titles on Netflix (Jan‚ÄìJun 2023)</strong></p>
<p>To ground the genre and format patterns in real examples, this table showcases the five most-watched Netflix releases from the first half of 2023. It includes both movies and TV shows across a variety of genres. These titles demonstrate how diverse content‚Äîfrom action-packed films to true crime docuseries‚Äîcan generate massive viewer engagement. Displaying this alongside the genre and duration breakdowns helps connect broader trends to familiar, recognisable shows.</p>
<div class="cell">
<div class="cell-output-display">
<table class="caption-top table table-sm table-striped small">
<caption>Table: Top 5 Most Watched Titles (Jan‚ÄìJun 2023)</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Title</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Total Hours Viewed</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Murder Mystery</td>
<td style="text-align: left;">Movie</td>
<td style="text-align: left;">87,900,000</td>
</tr>
<tr class="even">
<td style="text-align: left;">Extraction</td>
<td style="text-align: left;">Movie</td>
<td style="text-align: left;">86,100,000</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Stranger Things</td>
<td style="text-align: left;">TV Show</td>
<td style="text-align: left;">77,800,000</td>
</tr>
<tr class="even">
<td style="text-align: left;">The Croods</td>
<td style="text-align: left;">Movie</td>
<td style="text-align: left;">56,400,000</td>
</tr>
<tr class="odd">
<td style="text-align: left;">We Can Be Heroes</td>
<td style="text-align: left;">Movie</td>
<td style="text-align: left;">52,800,000</td>
</tr>
</tbody>
</table>
</div>
</div>
<p><br>
</p>
<p>To understand what types of content dominate viewer attention, total viewing hours were grouped by genre. Genres were extracted from the <code>listed_in</code> field and cleaned to remove duplicates.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="assignment4_Yashitta_Bawa_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p><strong>What it shows:</strong><br>
Comedies and dramas led in viewer engagement during the first half of 2023, each accumulating over a billion hours of global watch time. Family movies and action titles also performed strongly, indicating that genres with broad, cross-generational appeal tend to attract more viewers. In contrast, niche categories like horror and sci-fi saw lower total viewing hours, though they still ranked among the top ten.</p>
<hr>
</section>
<section id="genre-preferences-by-format" class="level4">
<h4 class="anchored" data-anchor-id="genre-preferences-by-format"><strong>2. Genre Preferences by Format</strong></h4>
<p>To compare how TV shows and movies perform across genres, titles were grouped by both <code>type</code> and <code>genre</code>, and total viewing hours were aggregated. This enabled a direct visual comparison of content preferences across formats.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="assignment4_Yashitta_Bawa_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p><strong>What it shows:</strong><br>
This chart compares the most-watched genres on Netflix across movies and TV shows. For movies, <strong>comedies</strong> and <strong>dramas</strong> led in total viewership, followed by action, romance, and thrillers. In contrast, top-performing TV content leaned toward <strong>mysteries</strong>, <strong>horror</strong>, and <strong>sci-fi/fantasy</strong> ‚Äî genres often associated with episodic suspense and extended story arcs.</p>
<p>The side-by-side layout clearly illustrates how <strong>audience preferences vary by format</strong>. While viewers tend to choose movies for emotionally driven or family-friendly stories, they often turn to TV shows for immersive, suspense-heavy narratives. This supports the idea that <strong>format influences viewing behaviour</strong>, with pacing and structure playing key roles in shaping genre appeal.</p>
<p><strong>Summary Table</strong><br>
While visual plots capture overall trends, this table highlights the five most-watched genres <strong>within each format</strong>. Action and comedy dominate the movie category, whereas crime and docuseries genres appear more frequently in top-performing TV content‚Äîreflecting the structural strengths of episodic storytelling in long-form viewing.</p>
<div class="cell">
<div class="cell-output-display">
<table class="caption-top table table-sm table-striped small">
<caption>Table: Top 5 Most Watched Genres by Format</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Format</th>
<th style="text-align: left;">Genre</th>
<th style="text-align: left;">Total Hours Viewed</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Movie</td>
<td style="text-align: left;">Comedies</td>
<td style="text-align: left;">1,871,200,000</td>
</tr>
<tr class="even">
<td style="text-align: left;">Movie</td>
<td style="text-align: left;">Dramas</td>
<td style="text-align: left;">1,531,900,000</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Movie</td>
<td style="text-align: left;">Children &amp; Family Movies</td>
<td style="text-align: left;">1,321,500,000</td>
</tr>
<tr class="even">
<td style="text-align: left;">Movie</td>
<td style="text-align: left;">Action &amp; Adventure</td>
<td style="text-align: left;">1,282,800,000</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Movie</td>
<td style="text-align: left;">Romantic Movies</td>
<td style="text-align: left;">673,300,000</td>
</tr>
<tr class="even">
<td style="text-align: left;">TV Show</td>
<td style="text-align: left;">TV Mysteries</td>
<td style="text-align: left;">123,700,000</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TV Show</td>
<td style="text-align: left;">TV Horror</td>
<td style="text-align: left;">118,600,000</td>
</tr>
<tr class="even">
<td style="text-align: left;">TV Show</td>
<td style="text-align: left;">TV Sci-Fi &amp; Fantasy</td>
<td style="text-align: left;">79,000,000</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TV Show</td>
<td style="text-align: left;">TV Dramas</td>
<td style="text-align: left;">55,200,000</td>
</tr>
<tr class="even">
<td style="text-align: left;">TV Show</td>
<td style="text-align: left;">International TV Shows</td>
<td style="text-align: left;">50,000,000</td>
</tr>
</tbody>
</table>
</div>
</div>
<hr>
</section>
<section id="is-longer-better" class="level4">
<h4 class="anchored" data-anchor-id="is-longer-better"><strong>3. Is Longer Better?</strong></h4>
<p>To examine the relationship between content length and viewer engagement, titles were grouped by format and visualised using separate violin plots‚Äîone for movie runtimes (in minutes) and another for TV show durations (in seasons).</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="assignment4_Yashitta_Bawa_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p><strong>What it shows:</strong><br>
There is no strong or consistent link between duration and total viewership. Most <strong>movies</strong> clustered around the 90‚Äì120 minute range, with a few shorter and longer outliers‚Äîyet both ends of the spectrum showed varying levels of engagement. <strong>TV shows</strong> were predominantly limited to one-season formats, with minimal variation across the dataset. This suggests that <strong>binge-worthiness is not solely determined by length</strong>. Elements such as content quality, genre, release timing, and episodic structure are likely more influential in sustaining viewer interest.</p>
<hr>
</section>
</section>
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion">üéØ Conclusion</h3>
<p>The analysis indicates that <strong>viewer engagement on Netflix is shaped by a combination of genre, format, and structural elements</strong>, rather than any single factor. While widely popular genres like <strong>comedies</strong> and <strong>dramas</strong> consistently attract high viewership, others‚Äîsuch as <strong>horror</strong> and <strong>sci-fi</strong>‚Äîperform more strongly within specific formats (e.g., TV shows).</p>
<p>The genre breakdown revealed clear distinctions between <strong>movies and series</strong>, with films leaning toward emotional or family-friendly themes, and shows favouring suspenseful, episodic storytelling. The duration analysis further showed that <strong>most movies run between 90‚Äì120 minutes</strong>, while <strong>TV shows typically span 1‚Äì2 seasons</strong>, though engagement does not necessarily increase with length.</p>
<p>For students exploring data storytelling, this project highlights how <strong>public datasets can reveal cultural patterns</strong> and viewing behaviour. Even simple preprocessing and visualisation choices‚Äîsuch as splitting mixed-duration fields or disaggregating genre labels‚Äîcan uncover meaningful insights hidden in plain sight.</p>
<hr>
</section>
<section id="references-1" class="level3">
<h3 class="anchored" data-anchor-id="references-1">üìö References</h3>
<ul>
<li>Netflix. <a href="https://about.netflix.com/en/news/what-we-watched-a-netflix-engagement-report"><em>What We Watched: A Netflix Engagement Report</em>.</a></li>
<li>Kaggle. <a href="https://www.kaggle.com/datasets/shivamb/netflix-shows"><em>Netflix Movies and TV Shows Dataset</em>.</a></li>
</ul>
<!-- Task 3 Tab: Behind the Scenes -  -->
</section>
</div>
<div id="tabset-1-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-3-tab">
<section id="genre-cleaning-and-duration-parsing" class="level3">
<h3 class="anchored" data-anchor-id="genre-cleaning-and-duration-parsing">üßπ Genre Cleaning and Duration Parsing</h3>
<p><strong>Tell us about a part(s) of your data processing or analysis that weren‚Äôt ‚Äúsexy‚Äù and wouldn‚Äôt typically be included in a blog post. (e.g.&nbsp;Was there any data drudgery or time intensive wrangling? Were there any repetitive tasks or manual tasks? If it was easy, describe what made it easy?)</strong></p>
<p>A surprising amount of time went into cleaning the <code>duration</code> and <code>listed_in</code> columns. The genre field contained comma-separated values, which meant entries had to be split, flattened, and reassigned before any meaningful grouping could happen. Similarly, standardising the duration format required parsing mixed strings like ‚Äú90 min‚Äù and ‚Äú1 Season‚Äù into clean numeric values. These weren‚Äôt difficult, but they were repetitive and fiddly ‚Äî and wouldn‚Äôt be obvious from the final visuals.</p>
<hr>
</section>
<section id="redesigning-visuals-and-adjusting-scope" class="level3">
<h3 class="anchored" data-anchor-id="redesigning-visuals-and-adjusting-scope">üß© Redesigning Visuals and Adjusting Scope</h3>
<p><strong>Were there any challenges that you faced in conducting this analysis? These may take the form of data limitations or coding challenges. (e.g.&nbsp;Was there anything in your analysis that you were not anticipating when you started? Did you have to change your intended scope? Did you need to master a new skill? Were there any problems you were proud of solving?)</strong></p>
<p>There were multiple rounds of visualisation redesigns. The original plan was to use radar and sunburst plots, but both were dropped ‚Äî either because they didn‚Äôt render correctly or didn‚Äôt support comparison well. Plotting duration was especially tricky because the unit was inconsistent (minutes for movies, seasons for shows). Getting those into a shared structure required recoding the logic several times. In the end, simple violin plots gave the most readable output.</p>
<hr>
</section>
<section id="opportunities-for-future-expansion" class="level3">
<h3 class="anchored" data-anchor-id="opportunities-for-future-expansion">üöÄ Opportunities for Future Expansion</h3>
<p><strong>Tell us about any imperfect parts of your work or how you would like to expand this analysis in future? (We don‚Äôt expect you to solve everything in one assignment.)</strong></p>
<p>The dataset only included total viewing hours and lacked contextual metadata such as drop-off rates or regional viewing patterns. As a result, it was difficult to tell whether high engagement reflected popularity, rewatchability, or algorithmic promotion. In the future, it would be useful to bring in complementary data ‚Äî such as country-level trends, viewer completion rates, or IMDb scores ‚Äî to round out the picture and understand <em>why</em> certain shows succeeded.</p>
<hr>
</section>
<section id="iterative-process-version-history" class="level3">
<h3 class="anchored" data-anchor-id="iterative-process-version-history">üß™ Iterative Process &amp; Version History</h3>
<p>This project was developed through five saved versions, reflecting how both the analysis and communication evolved. Below is a brief summary of what changed at each stage:</p>
<p><strong>Version 1 ‚Äì Initial Write-Up Only (f6bf9b9)</strong></p>
<ul>
<li><p>Drafted Tab 1 with research question, data sources, and collection process</p></li>
<li><p>Focused on structuring ideas before adding any code or visuals</p></li>
<li><p>Helped clarify project direction and key questions</p></li>
</ul>
<p><strong>Version 2 ‚Äì Data Cleaning and Exploratory Code (85bd5aa)</strong></p>
<ul>
<li><p>Added early data wrangling and merging code in R</p></li>
<li><p>Began exploring how to standardise duration and split genres</p></li>
<li><p>Tested out plots to verify structure, most of which were later refined or discarded</p></li>
</ul>
<p><strong>Version 3 ‚Äì Visualisations and Tables Added in Tab 2 (bf6abd9)</strong></p>
<ul>
<li><p>Created final faceted bar charts and violin plots</p></li>
<li><p>Added genre and format summary tables</p></li>
<li><p>Focused on aligning visuals with story flow and improving interpretability</p></li>
</ul>
<p><strong>Version 4 ‚Äì Tab 3 Reflections and Drafting (d62ef77)</strong></p>
<ul>
<li><p>Wrote behind-the-scenes reflections for Tab 3</p></li>
<li><p>Described challenges, scope shifts, and future opportunities</p></li>
<li><p>Ensured tone was natural and authentic rather than AI-generated</p></li>
</ul>
<p><strong>Version 5 ‚Äì Final Polish, Styling, and Documentation (6d2a93b)</strong></p>
<ul>
<li><p>Applied full custom CSS (Netflix theme, tab design, pastel code blocks)</p></li>
<li><p>Edited all write-ups for grammar, clarity, and tone consistency</p></li>
<li><p>Added AI acknowledgment (ChatGPT query link), and final section in Tab 3</p></li>
<li><p>Included README and data description files to complete the submission</p></li>
</ul>
<p>All versions of this assignment, including exploratory code, intermediate drafts, and final outputs, are available on GitHub:<br>
<a href="https://github.com/Yashitta/ETC-5512_Assignment_4.git">GitHub Repository</a></p>
</section>
</div>
</div>
</div>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>